--track0:距離,0,500,50
--track1:縁の太さ,1,50,5
--track2:角度,0,359,90
--track3:曲面閾値,0,359,10
--check0:拡張面表示,0
--dialog:頂点閾値,local apexThreshold=3;輪郭番号表示/chk,local displayOutlineNo=0;外枠:1 内枠:2,local outOrIn={};デバッグ用,local debugno=0;

-- ====================
-- == デバッグ用 ↓
-- ====================

debug_print("===================")
debug_print("== スクリプト開始 ==")
debug_print("===================")

-- 一次元配列用
-- @param a 一次元配列
-- @param name 配列名
local function debugPrintArray(a, name)
    debug_print("== debugPrintArray("..name..") ↓ ==")
    for i = 1, #a do
        debug_print("i="..i..", value="..a[i])
    end
    debug_print("== debugPrintArray("..name..") ↑ ==")
end

-- 二次元配列用
-- @param a 二次元配列
local function debugPrintNestedArray(a)
    debug_print("== debugPrintNestedArray() ↓ ==")
    for i = 1, #a do
        for j = 1, #a[i] do
            debug_print("i="..i..", j="..j..", value="..a[i][j])
        end
    end
    debug_print("== debugPrintNestedArray() ↑ ==")
end

-- 輪郭情報
-- @param outlines 輪郭[[x0, y0, x1, y1, x2, y2, ...], [], ...]
-- @param name 輪郭名
function debugPrintOutlines(outlines, name)
    debug_print("== 輪郭座標（"..name.."）↓ ==")
    for i = 1, #outlines do
        local n = #outlines[i]
        for j = 1, n / 2 do
            debug_print("i="..i..", j="..j..", x="..outlines[i][j*2-1]..", y="..outlines[i][j*2])
        end
    end
    debug_print("== 輪郭座標（"..name.."）↑ ==")
end

-- 辺情報
-- @param lines 辺[{x0, y0, x1, y1}, {}, ...]
local function debugPrintAndDrawLineDetection(lines)
    debug_print("== 辺座標 ↓ ==")
    obj.setfont("ＭＳ ゴシック", 14, 0, "0xff0000")
    local yyy = 15
    debug_print("#lines="..#lines)
    for i = 1, #lines do
        local x = lines[i].x0
        local y = lines[i].y0
        obj.load("text", i)
        obj.draw(x, y)
        obj.load("text", string.format("%.2f", x))
        obj.draw(x, y + yyy)
        obj.load("text", string.format("%.2f", y))
        obj.draw(x, y + yyy * 2)
        debug_print("i="..i..", x="..x..", y="..y)
    end
    debug_print("== 辺座標 ↑ ==")
end

-- 辺情報
-- @param lines 辺[{x0, y0, x1, y1}, {}, ...]
-- @param name 配列名
local function debugPrintLines(lines, name)
    debug_print("== 辺座標（"..name.."）↓ ==")
    local n = #lines
    debug_print("[debugSides()]n="..n)
    for i = 1, n do
        local edge = lines[i]
        local x = edge.x0
        local y = edge.y0
        debug_print("x0="..x..", y0="..y)
    end
    debug_print("== 辺座標（"..name.."）↑ ==")
end

-- ====================
-- == デバッグ用 ↑
-- ====================

local distance = obj.track0
local edgeWeight = obj.track1
local angle = obj.track2
local radius = math.rad(angle)
local angleThreshold = obj.track3

local w, h = obj.getpixel()
local offsetX = w / 2
local offsetY = h / 2

obj.copybuffer("cache:img", "obj")
local baseX = obj.ox
local baseY = obj.oy

require("rikky_module")

-- 輪郭情報
pointsEachOutlines, numPointsEachOutlines, numOutlines = rikky_module.bordering()

-- 辺情報
lines, numLines = rikky_module.linedetection(100)

-- 辺の終点を近隣の辺の始点の値に設定
-- {{x0, y0, x1, y1},{},...}
local correctedLines = {}

for i = 1, numLines do
    local origin = lines[i]
    local x0, y0 = origin.x0, origin.y0
    local x1, y1 = origin.x1, origin.y1
--    debug_print("x0:"..x0..", y0:"..y0..", x1:"..x1..", y1:"..y1)

    for j = 1, numLines do
        if (i == j) then
            goto continue
        end

        local dest = lines[j]
        local x2, y2 = dest.x0, dest.y0
        local x3, y3 = dest.x1, dest.y1
--        debug_print("x2:"..x2..", y2:"..y2..", x3:"..x3..", y3:"..y3)

        -- おそらく各辺の始点と終点は輪郭の反時計回りに沿う形で取得できる。
        -- つまり、始点同士・終点同士が重なることはない。多分…。
--        debug_print("dx="..math.abs(x1 - x2))
--        debug_print("dy="..math.abs(y1 - y2))
        if ((math.abs(x1 - x2) < apexThreshold) and (math.abs(y1 - y2) < apexThreshold)) then
--            debug_print("kkkkk")
            local angleOrigin = math.deg(math.atan2(y1 - y0, x1 - x0))
            local angleDest = math.deg(math.atan2(y3 - y2, x3 - x2))
            local da = math.abs(angleOrigin - angleDest) % 360

            correctedLines[i] = {
                x0 = x0
                , y0 = y0
                , x1 = x2
                , y1 = y2
            }

            break
        end
        ::continue::
    end
--    debugPrintLines(correctedLines, "correctedLines")
end

-- 辺を輪郭に変換
-- [[x0, y0, x1, y1, ...],[],...]
local rinnkaku = {}

local function transLineToOutline()
    local dupLines = {}
    for i = 1, #correctedLines do
        table.insert(dupLines, correctedLines[i])
    end

    local outlines = {}
    local removingIndexes = {}

    -- 辺の始点を輪郭配列に追加する再帰関数
    -- @param first なんちゅーの 分かってくれよ
    -- @param index 辺のインデックス
    local function addStartPoints(first, index)
        -- 1周したら
        if (first == false and index == #dupLines) then
            return
        end

        local origin = dupLines[index]

        for i = 1, #dupLines do
            local dest = dupLines[i]
            if (origin.x0 == dest.x1 and origin.y0 == dest.y1) then
                addStartPoints(false, i)
                table.insert(outlines, origin.x0)
                table.insert(outlines, origin.y0)
                table.insert(removingIndexes, i)
                break
            end
        end
    end

    while true do
        local n = #dupLines

        if (n == 0) then
            break
        end

        addStartPoints(true, n)

        table.insert(rinnkaku, outlines)

        -- 輪郭にした辺を削除
--        debugPrintArray(outlines, "outlines")
--        debugPrintArray(removingIndexes, "removingIndexes")
--        debugPrintLines(dupLines, "dupLines")
        for i = #removingIndexes, 1, -1 do
            local index = table.remove(removingIndexes)
            table.remove(dupLines, index)
            for j = 1, #removingIndexes do
                if (removingIndexes[j] > index) then
                    removingIndexes[j] = removingIndexes[j] - 1
                end
            end
        end
--        debugPrintArray(removingIndexes, "removingIndexes")
--        debugPrintLines(dupLines, "dupLines")

        outlines = {}
    end
end
transLineToOutline()

debugPrintOutlines(rinnkaku, "rinnkaku")

-- @param t テーブル
-- @param p インサート位置
-- @param v インサート値
local function insert(t, p, v)
    local temp = {}
    -- pop
    for i = #t, p, -1 do
        table.insert(temp, table.remove(t))
    end
    table.insert(t, v)
    -- push
    for i = #temp, 1, -1 do
        table.insert(t, temp[i])
    end
end

-- 側面描画順2
-- [{index = number, order = [n1, n2, n3, ...]}, {}, ...]
local drawingOrder2 = {}
local function lsls()

    -- @param rnkk 輪郭[x0, y0, x1, y1, ...]
    -- @return 順番[n1, n2, n3, ...]
    local function sortDrawingOrder(rnkk)
        -- [{i, r}, {}, ...]
        local rs = {}

        for i = 1, #rnkk / 2 do
            local x, y, r
            if (0 <= radius and radius < math.pi * (1/2)) then
                -- 0〜90度の場合、各座標を原点の右下にシフト
                x = rnkk[i * 2 - 1]
                y = rnkk[i * 2]
            elseif (math.pi * (1/2) <= radius and radius < math.pi) then
                -- 90〜180度の場合、各座標を原点の左下にシフト
                x = rnkk[i * 2 - 1] - w
                y = rnkk[i * 2]
            elseif (math.pi <= radius and radius < math.pi * (3/2)) then
                -- 180〜270度の場合、各座標を原点の左上にシフト
                x = rnkk[i * 2 - 1] - w
                y = rnkk[i * 2] - h
            elseif (math.pi * (3/2) <= radius and radius < math.pi * 2) then
                -- 270〜360度の場合、各座標を原点の右上にシフト
                x = rnkk[i * 2 - 1]
                y = rnkk[i * 2] - h
            end
            r = math.sqrt(x * x + y * y)
            table.insert(rs, {i = i, r = r})
        end

        for i = 1, #rs do
            debug_print("rs:"..rs[i].i..","..rs[i].r)
        end

        -- 原点から遠い順に描画順を設定
        table.sort(
            rs
            , function(a, b)
                return a.r > b.r
            end
        )

        local order = {}
        for i = 1, #rs do
            table.insert(order, rs[i].i)
        end

        return order
    end

    local numOutOrIn = #outOrIn
    local numRinnkaku = #rinnkaku
    if (numOutOrIn == 0) then
        -- 順番考慮なし
        debug_print("順番考慮なし")
        for i = 1, numRinnkaku do
            table.insert(drawingOrder2, {
                index = i
                , order = sortDrawingOrder(rinnkaku[i])
            })
        end
    elseif (numOutOrIn == numRinnkaku) then
        -- 順番考慮あり（内側->外側）
        debug_print("順番考慮あり（内側->外側）")
        for i = 1, numRinnkaku do
            if (outOrIn[i] == 2) then
                table.insert(drawingOrder2, {
                    index = i
                    , order = sortDrawingOrder(rinnkaku[i])
                })
            end
        end
        for i = 1, numRinnkaku do
            if (outOrIn[i] == 1) then
                table.insert(drawingOrder2, {
                    index = i
                    , order = sortDrawingOrder(rinnkaku[i])
                })
            end
        end
    end
end
lsls()

-- drawingOrder2 = [{index = number, order = [n1, n2, n3, ...]}, {}, ...]
for i = 1, #drawingOrder2 do
    for j = 1, #drawingOrder2[i].order do
        debug_print("index="..drawingOrder2[i].index..", order["..j.."]="..drawingOrder2[i].order[j])
    end
end

-- 基準面_縁取り
local function drawBaseEdge()
    obj.load("figure", "円", "0xffffff", edgeWeight)

    for i = 1, numOutlines do
        for j = 1, numPointsEachOutlines[i] do
            obj.ox = pointsEachOutlines[i][j*2-1] + offsetX
            obj.oy = pointsEachOutlines[i][j*2] + offsetY
            obj.draw()
        end
    end
end

--drawBaseEdge()

--jjj()

-- 縁取り_基準面と拡張面を繋ぐ辺

local function drawSide2()
    for i = 1, #drawingOrder2 do
        local index = drawingOrder2[i].index
        local orders = drawingOrder2[i].order
        local rnkk = rinnkaku[index]

        for j = 1, #orders do
            local x0 = rnkk[(orders[j] * 2) - 1]
            local y0 = rnkk[(orders[j] * 2)]
            local x1 = rnkk[(orders[j] * 2) % #rnkk + 1]
            local y1 = rnkk[(orders[j] * 2) % #rnkk + 2]
            local rad = math.atan2(y1 - y0, x1 - x0)

            -- radius: x = 1, y = 0 から時計周り 0 <= radius <= 2pi
            -- rad: x = -1, y = 0 から時計回り -pi <= rad <= pi

            if (0 <= radius and radius < math.pi) then
                -- 0〜180度
                if (radius - math.pi <= rad and rad <= radius) then
                    goto continue
                end
            elseif (radius < math.pi * 2) then
                -- 180〜360度
                local r = (rad + 2 * math.pi) % (2 * math.pi)
                if (radius - math.pi <= r and r <= radius) then
                    goto continue
                end
            end
            -- 面
            obj.load("figure", "四角形", "0x00aa00")

            local x2 = distance * math.cos(radius) + x1
            local y2 = distance * math.sin(radius) + y1
            local x3 = distance * math.cos(radius) + x0
            local y3 = distance * math.sin(radius) + y0

            obj.drawpoly(
                x0, y0, 0
                , x1, y1, 0
                , x2, y2, 0
                , x3, y3, 0
            )

            -- 辺
            obj.load("figure", "円", "0xffffff", edgeWeight)

            -- 前の辺に対して現在の辺がほぼ平行（ほぼ直線）の場合、縁取りしない。
--            if (side.da < angleThreshold) then
--                goto continue
--            end

            -- 辺の始点から縁取りを描画
            for j = 0, distance do
                obj.ox = ((x3 - x0) * j / distance) + x0
                obj.oy = ((y3 - y0) * j / distance) + y0
                obj.draw()
            end

            ::continue::
        end
    end
end

-- 拡張面
local function drawExSurface()
    obj.copybuffer("obj", "cache:img")

    obj.ox = distance * math.cos(radius) + offsetX
    obj.oy = distance * math.sin(radius) + offsetY
    obj.draw()
end

-- 拡張面_縁取り
local function drawExEdge()
    obj.load("figure", "円", "0xffffff", edgeWeight)
    for i = 1, numOutlines do
        for j = 1, numPointsEachOutlines[i] do
            local x = pointsEachOutlines[i][j*2-1]
            local y = pointsEachOutlines[i][j*2]
            local exX = pointsEachOutlines[i][j*2-1] + distance
            local exY = pointsEachOutlines[i][j*2]
            local dx = exX - x
            local dy = exY - y
            -- dyのが常に0でなぜうまくいく？
            local r = math.atan2(0, dx) + radius
            obj.ox = math.cos(r) * distance + x + offsetX
            obj.oy = math.sin(r) * distance + y + offsetY
            obj.draw()
        end
    end
end

drawBaseEdge()
drawSide2()
if (obj.check0) then
    drawExSurface()
end
drawExEdge()

-- 輪郭番号の表示
if (displayOutlineNo == 1) then
    obj.setfont("ＭＳ ゴシック", 30, 0, "0xff0000")
    for i = 1, #rinnkaku do
        obj.load("text", "["..i.."]")
        obj.draw(rinnkaku[i][1], rinnkaku[i][2])
    end
end

-- ====================
-- == デバッグ用 ↓
-- ====================

-- オリジナルの描画順を表示する。
local function dubugDrawOriginalDrawingOrder()
    obj.setfont("ＭＳ ゴシック", 20, 0, "0xff0000")
    obj.load("text", "●")
    obj.draw(0, 0)
    obj.setfont("ＭＳ ゴシック", 20, 0, "0x0000ff")
    obj.load("text", "●")
    obj.draw(w, h)
    obj.setfont("ＭＳ ゴシック", 16, 0, "0xff0000")
    for i = 1, #drawingOrder2 do
        local index = drawingOrder2[i].index
        local orders = drawingOrder2[i].order
        local rnkk = rinnkaku[index]

        for j = 1, #orders do
            local x = rnkk[j * 2 - 1]
            local y = rnkk[j * 2]
            obj.load("text", i.."-"..j)
            obj.draw(x, y)
        end
    end
end

-- ソート済みの描画順を表示する。
local function debugDrawSortedDrawingOrder()
    obj.setfont("ＭＳ ゴシック", 20, 0, "0xff0000")
    obj.load("text", "●")
    obj.draw(0, 0)
    obj.setfont("ＭＳ ゴシック", 20, 0, "0x0000ff")
    obj.load("text", "●")
    obj.draw(w, h)
    obj.setfont("ＭＳ ゴシック", 16, 0, "0xff0000")
    for i = 1, #drawingOrder2 do
        local index = drawingOrder2[i].index
        local orders = drawingOrder2[i].order
        local rnkk = rinnkaku[index]

        for j = 1, #orders do
            local x = rnkk[(orders[j] * 2) - 1]
            local y = rnkk[(orders[j] * 2)]
            obj.load("text", i.."-"..j)
            obj.draw(x, y)
        end
    end
end

if (debugno == 1) then
    dubugDrawOriginalDrawingOrder()
elseif (debugno == 2) then
    debugDrawSortedDrawingOrder()
elseif (debugno == 3) then
    debugPrintAndDrawLineDetection(correctedLines)
end

debug_print("===================")
debug_print("== スクリプト終了 ==")
debug_print("===================")

-- ====================
-- == デバッグ用 ↑
-- ====================
