--track0:距離,0,500,50
--track1:縁の太さ,1,50,5
--track2:角度,0,359,90
--track3:曲面閾値,0,359,10
--dialog:頂点閾値,local apexThreshold=3;

local distance = obj.track0
local edgeWeight = obj.track1
local angle = obj.track2
local radius = math.rad(angle)
local angleThreshold = obj.track3

local w, h = obj.getpixel()
local offsetX = w / 2
local offsetY = h / 2

obj.copybuffer("cache:img", "obj")
local baseX = obj.ox
local baseY = obj.oy

require("rikky_module")

--table 各輪郭の座標データ {{x0,y0,x1,y1,x2,y2,....},{...},...}の形式
--table 各輪郭の点の数 {n0,n1,n2,...}の形式
--number 輪郭の数
-- 輪郭情報
pointsEachOutlines, numPointsEachOutlines, numOutlines = rikky_module.bordering()

-- 辺情報
edges, numEdges = rikky_module.linedetection(100)

-- デバッグ用
local function debugPoints()
    obj.setfont("ＭＳ ゴシック", 20, 0, "0xff0000")
    local yyy = 15
    for i = 1, table.getn(edges) do
        local x = edges[i].x0
        local y = edges[i].y0
        obj.load("text", "i="..i)
        obj.draw(x, y)
        obj.load("text", "x="..string.format("%.2f", x))
        obj.draw(x, y + yyy)
        obj.load("text", "y="..string.format("%.2f", y))
        obj.draw(x, y + yyy * 2)
    end
end
--debugPoints()

------------
--
-- 始点情報矯正 ここから
--
------------

-- {[{index, value},{},...],[],...}
local xs = {}
local ys = {}
local correctionThreshold = 2

local xs1 = {}
table.insert(xs1, {index = 1, value = edges[1].x0})
table.insert(xs, xs1)
local ys1 = {}
table.insert(ys1, {index = 1, value = edges[1].y0})
table.insert(ys, ys1)

for i = 2, numEdges do
    local edge = edges[i]
    local alreadyGroupingX = false
    local alreadyGroupingY = false

    -- x座標のグループ分け
    for j = 1, table.getn(xs) do
        local xv = xs[j][1].value
        if (math.abs(xv - edge.x0) <= 2) then
            table.insert(xs[j], {index = i, value = edge.x0})
            alreadyGroupingX = true
        end
    end

    -- 新しいグループを作成する。
    if (alreadyGroupingX == false) then
        local xsi = {}
        table.insert(xsi, {index = i, value = edge.x0})
        table.insert(xs, xsi)
    end

    -- y座標のグループ分け
    for j = 1, table.getn(ys) do
        local yv = ys[j][1].value
        if (math.abs(yv - edge.y0) <= 2) then
            table.insert(ys[j], {index = i, value = edge.y0})
            alreadyGroupingY = true
        end
    end

    -- 新しいグループを作成する。
    if (alreadyGroupingY == false) then
        local ysi = {}
        table.insert(ysi, {index = i, value = edge.y0})
        table.insert(ys, ysi)
    end
end

local function debugPrintGroups()
    debug_print("== xs ==")
    for i = 1, table.getn(xs) do
        for j = 1, table.getn(xs[i]) do
            debug_print("xs["..i.."]["..j.."].index="..xs[i][j].index..", value="..xs[i][j].value)
        end
    end
    debug_print("== ys ==")
    for i = 1, table.getn(ys) do
        for j = 1, table.getn(ys[i]) do
            debug_print("ys["..i.."]["..j.."].index="..ys[i][j].index..", value="..ys[i][j].value)
        end
    end
end
debugPrintGroups()

-- グループ分けした値を平均する。
local xsa = {}
local ysa = {}

for i = 1, table.getn(xs) do
    local n = 0
    local sum = 0
    for j = 1, table.getn(xs[i]) do
        sum = sum + xs[i][j].value
        n = n + 1
    end
    local ave = sum / n
    xsaa = {}
    for j = 1, table.getn(xs[i]) do
        local xsiaa = {index = xs[i][j].index, value = ave}
        table.insert(xsaa, xsiaa)
    end
    table.insert(xsa, xsaa)
end

-- グループ分けした値を平均する。
for i = 1, table.getn(ys) do
    local n = 0
    local sum = 0
    for j = 1, table.getn(ys[i]) do
        sum = sum + ys[i][j].value
        n = n + 1
    end
    local ave = sum / n
    ysaa = {}
    for j = 1, table.getn(ys[i]) do
        local ysiaa = {index = ys[i][j].index, value = ave}
        table.insert(ysaa, ysiaa)
    end
    table.insert(ysa, ysaa)
end

local function debugPrintAveragedGroups()
    debug_print("== xsa ==")
    for i = 1, table.getn(xsa) do
        for j = 1, table.getn(xsa[i]) do
            debug_print("xsa["..i.."]["..j.."].index="..xsa[i][j].index..", value="..xsa[i][j].value)
        end
    end
    debug_print("== ysa ==")
    for i = 1, table.getn(ysa) do
        for j = 1, table.getn(ysa[i]) do
            debug_print("ysa["..i.."]["..j.."].index="..ysa[i][j].index..", value="..ysa[i][j].value)
        end
    end
end
debugPrintAveragedGroups()

-- 辺テーブルに詰めなおす
-- [{x0, y0, x1, y1},{},...]
local correctedEdges = {}

local function makeEdges()
    for i = 1, table.getn(xsa) do
        for j = 1, table.getn(xsa[i]) do
            local xIndex = xsa[i][j].index
            local x0 = xsa[i][j].value
            local yIndex = 0
            local y0 = 0
            for k = 1, table.getn(ysa) do
                for l = 1, table.getn(ysa[k]) do
                    yIndex = ysa[k][l].index
                    if (xIndex == yIndex) then
                        y0 = ysa[k][l].value
                        goto breakY
                    end
                end
            end
            ::breakY::
            local edge = edges[xIndex]
            local x1 = edge.x1
            local y1 = edge.y1
            table.insert(correctedEdges, {x0 = x0, y0 = y0, x1 = x1, y1 = y1})
        end
    end
end
makeEdges()

local function debugPrintCorrectedEdges()
    debug_print("== correctedEdges("..table.getn(correctedEdges)..") ==")
    for i = 1, table.getn(correctedEdges) do
        debug_print("["..i.."]x0="..correctedEdges[i].x0..", y0="..correctedEdges[i].y0..", x1="..correctedEdges[i].x1..", y1="..correctedEdges[i].y1)
    end
end
debugPrintCorrectedEdges()

------------
--
-- 始点情報矯正 ここまで
--
------------

-- 側面テーブル
-- {{x0, y0, x1, y1, x2, y2, x3, x4, da},{},...}
local sides = {}
local numSides = 0

for i = 1, numEdges do
    local origin = correctedEdges[i]
    local x0, y0 = origin.x0, origin.y0
    local x1, y1 = origin.x1, origin.y1
--    debug_print("x0:"..x0..", y0:"..y0..", x1:"..x1..", y1:"..y1)

    for j = 1, numEdges do
        if (i == j) then
            goto continue
        end

        local dest = correctedEdges[j]
        local x2, y2 = dest.x0, dest.y0
        local x3, y3 = dest.x1, dest.y1
--        debug_print("x2:"..x2..", y2:"..y2..", x3:"..x3..", y3:"..y3)

        -- おそらく輪郭の各辺の始点と終点は反時計回りに沿う形で取得できる。
        -- つまり、必ず始点と終点が重なり、始点同士・終点同士が重なることはない。多分…。
        if ((math.abs(x1 - x2) < apexThreshold) and (math.abs(y1 - y2) < apexThreshold)) then
            local angleOrigin = math.deg(math.atan2(y1 - y0, x1 - x0))
            local angleDest = math.deg(math.atan2(y3 - y2, x3 - x2))

            local da = math.abs(angleOrigin - angleDest) % 360

            local t = {
                x0 = x0, y0 = y0
                , x1 = x2, y1 = y2
                , x2 = distance * math.cos(radius) + x2, y2 = distance * math.sin(radius) + y2
                , x3 = distance * math.cos(radius) + x0, y3 = distance * math.sin(radius) + y0
                , da = da
            }
            sides[i] = t
            numSides = numSides + 1

            break
        end
        ::continue::
    end
end

local function debugPrintOriginalDrawingOrder()
    local n = table.getn(sides)
    debug_print("[debugPrintOriginalDrawingOrder()]n="..n)
    for i = 1, table.getn(sides) do
        local side = sides[i]

        obj.setfont("ＭＳ ゴシック", 16, 0, "0xff0000")
        local x = side.x0
        local y = side.y0
        obj.load("text", i.."["..i.."]")
        obj.draw(x, y)
    end
end
--debugPoints()
--debugPrintOriginalDrawingOrder()

-- @param t テーブル
-- @param p インサート位置
-- @param v インサート値
local function insert(t, p, v)
    local temp = {}
    -- pop
    for i = table.getn(t), p, -1 do
        table.insert(temp, table.remove(t))
    end
    table.insert(t, v)
    -- push
    for i = table.getn(temp), 1, -1 do
        table.insert(t, temp[i])
    end
end

local function debugPrintTable(t)
    for i = 1, table.getn(t) do
        debug_print(i..":"..t[i])
    end
end

-- 側面描画順
local drawingOrder = {}
local function jjj()
    local reverseOrder = {1}

    for i = 2, numSides do
        local insertPoint = 1
        local sideI = sides[i]

        for j = table.getn(reverseOrder) + 1, 2, -1 do
            local sideJ = sides[reverseOrder[j - 1]]
            -- 右下->左上
--            if (angle < 45) then
--                if (sideJ.x0 < sideI.x0) then
--                    insertPoint = j
--                    break
--                elseif (sideJ.x0 == sideI.x0 and sideJ.y0 < sideI.y0) then
--                    insertPoint = j
--                    break
--                end
            -- 下右->上左
            if (angle < 90) then
                if (sideJ.y0 < sideI.y0) then
                    insertPoint = j
                    break
                elseif (sideJ.y0 == sideI.y0 and sideJ.x0 < sideI.x0) then
                    insertPoint = j
                    break
                end
            -- 下左->上右
--            elseif (angle < 135) then
--                if (sideJ.y0 < sideI.y0) then
--                    insertPoint = j
--                    break
--                elseif (sideJ.y0 == sideI.y0 and sideJ.x0 > sideI.x0) then
--                    insertPoint = j
--                    break
--                end
            -- 左下->右上
            elseif (angle < 180) then
                if (sideJ.x0 > sideI.x0) then
                    insertPoint = j
                    break
                elseif (sideJ.x0 == sideI.x0 and sideJ.y0 < sideI.y0) then
                    insertPoint = j
                    break
                end
            -- 左上->右下
--            elseif (angle < 225) then
--                if (sideJ.x0 > sideI.x0) then
--                    insertPoint = j
--                    break
--                elseif (sideJ.x0 == sideI.x0 and sideJ.y0 > sideI.y0) then
--                    insertPoint = j
--                    break
--                end
            -- 上左->下右
            elseif (angle < 270) then
                if (sideJ.y0 > sideI.y0) then
                    insertPoint = j
                    break
                elseif (sideJ.y0 == sideI.y0 and sideJ.x0 > sideI.x0) then
                    insertPoint = j
                    break
                end
            -- 上右->下左
--            elseif (angle < 315) then
--                if (sideJ.y0 > sideI.y0) then
--                    insertPoint = j
--                    break
--                elseif (sideJ.y0 == sideI.y0 and sideJ.x0 < sideI.x0) then
--                    insertPoint = j
--                    break
--                end
            -- 右上->左下
            elseif (angle < 360) then
                if (sideJ.x0 < sideI.x0) then
                    insertPoint = j
                    break
                elseif (sideJ.x0 == sideI.x0 and sideJ.y0 < sideI.y0) then
                    insertPoint = j
                    break
                end
            end
        end

        insert(reverseOrder, insertPoint, i)
    end

    for i = 1, table.getn(reverseOrder) do
        table.insert(drawingOrder, table.remove(reverseOrder))
    end
end

jjj()

for i = 1, table.getn(drawingOrder) do
    debug_print(i..":"..drawingOrder[i])
end

--debug_print(numSides)
--for i = 1, numSides do
--    local side = sides[i]
--    debug_print(side.x0..","..side.y0..","..side.x1..","..side.y1..","..side.x2..","..side.y2..","..side.da)
--end

-- 基準面_縁取り
local function drawBaseEdge()
    obj.load("figure", "円", "0xffffff", edgeWeight)

    for i = 1, numOutlines do
        for j = 1, numPointsEachOutlines[i] do
            obj.ox = pointsEachOutlines[i][j*2-1] + offsetX
            obj.oy = pointsEachOutlines[i][j*2] + offsetY
            obj.draw()
        end
    end
end

-- 側面
local function drawSide()
    obj.load("figure", "四角形", "0x00aaaa")

    for i = 1, numSides do
        local side = sides[i]

        obj.drawpoly(
            side.x0, side.y0, 0
            , side.x1, side.y1, 0
            , side.x2, side.y2, 0
            , side.x3, side.y3, 0
        )
    end
end

-- 縁取り_基準面と拡張面を繋ぐ辺
local function drawSideEdge()
    obj.load("figure", "円", "0xffffff", edgeWeight)

    for i = 1, numSides do
        local side = sides[i]

        if (side.da < angleThreshold) then
            goto continue
        end

        for j = 0, distance do
            obj.ox = ((side.x2 - side.x1) * j / distance) + side.x1
            obj.oy = ((side.y2 - side.y1) * j / distance) + side.y1
            obj.draw()
        end

        ::continue::
    end
end

local function drawSide2()
    for i = 1, table.getn(drawingOrder) do
        -- 面
        obj.load("figure", "四角形", "0x00aa00")

        local side = sides[drawingOrder[i]]
        obj.drawpoly(
            side.x0, side.y0, 0
            , side.x1, side.y1, 0
            , side.x2, side.y2, 0
            , side.x3, side.y3, 0
        )

        -- 辺
        obj.load("figure", "円", "0xffffff", edgeWeight)

        if (side.da < angleThreshold) then
            goto continue
        end

        for j = 0, distance do
            obj.ox = ((side.x3 - side.x0) * j / distance) + side.x0
            obj.oy = ((side.y3 - side.y0) * j / distance) + side.y0
            obj.draw()
        end

        ::continue::
    end
end

-- 拡張面
local function drawExSurface()
    obj.copybuffer("obj", "cache:img")

    obj.ox = distance * math.cos(radius) + offsetX
    obj.oy = distance * math.sin(radius) + offsetY
    obj.draw()
end

-- 拡張面_縁取り
local function drawExEdge()

    obj.load("figure", "円", "0xffffff", edgeWeight)
    for i = 1, numOutlines do
        for j = 1, numPointsEachOutlines[i] do
            local x = pointsEachOutlines[i][j*2-1]
            local y = pointsEachOutlines[i][j*2]
            local exX = pointsEachOutlines[i][j*2-1] + distance
            local exY = pointsEachOutlines[i][j*2]
            local dx = exX - x
            local dy = exY - y
            -- dyのが常に0でなぜうまくいく？
            local r = math.atan2(0, dx) + radius
            obj.ox = math.cos(r) * distance + x + offsetX
            obj.oy = math.sin(r) * distance + y + offsetY
            obj.draw()
        end
    end
end

local function debugPrintSortedDrawingOrder()
    for i = 1, table.getn(drawingOrder) do
        local side = sides[drawingOrder[i]]

        obj.setfont("ＭＳ ゴシック", 16, 0, "0xff0000")
        local x = side.x0
        local y = side.y0
        obj.load("text", i.."["..drawingOrder[i].."]")
        obj.draw(x, y)
    end
end

drawBaseEdge()
--drawSide()
--drawSideEdge()
drawSide2()
drawExSurface()
drawExEdge()
--debugPoints()
--debugPrintSortedDrawingOrder()
--debugPrintOriginalDrawingOrder()

debug_print("==")
